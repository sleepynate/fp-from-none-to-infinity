<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Functional Programming 101</title>
<meta name="author" content="(Nathan Dotz)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="reveal.js-3.3.0/css/reveal.css"/>

<link rel="stylesheet" href="reveal.js-3.3.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="reveal.js-3.3.0/lib/css/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///Users/sleepynate/Dropbox%20(Personal)/org-mode/reveal.js-3.3.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Functional Programming 101</h1><h2 class="author">Nathan Dotz</h2><h2 class="date">Codemash 2017</h2>
</section>

<section>
<section id="slide-org074a6c2">
<h2 id="org074a6c2">Overview</h2>
<ul>
<li>Learn Functional Programming from scratch</li>
<li>Static &amp; strongly typed functional language (ML)</li>
<li>Weak &amp; dynamically typed functional language (racket)</li>
<li>Work on using concepts we learned in your language</li>

</ul>
</section>
</section>
<section>
<section id="slide-org09cd671">
<h2 id="org09cd671">Do your best to</h2>
<ul>
<li>Ignore the FP concepts you've tried to learn already</li>
<li>Not compare to your normal language</li>
<li>Treat these as completely new concepts</li>

</ul>
</section>
</section>
<section>
<section id="slide-orge28c8d6">
<h2 id="orge28c8d6">What is Functional Programming?</h2>
<div class="outline-text-2" id="text-orge28c8d6">
</div></section>
<section id="slide-org2d54479">
<h3 id="org2d54479">Did you guess</h3>
<ul>
<li>Lambdas λ</li>
<li>Higher-order functions</li>
<li>Functions are first-class citizens</li>

</ul>
</section>
<section id="slide-orgade467f">
<h3 id="orgade467f">Well sure, but what we're after is</h3>
<ul>
<li>elimination of state</li>
<li>elimination of effects</li>

</ul>

<p>
via
</p>

<ul>
<li>higher order functions</li>
<li>referential transparency</li>

</ul>
</section>
<section id="slide-org4976a5b">
<h3 id="org4976a5b">In short</h3>
<ul>
<li>pass everything into scope</li>
<li>every scope returns a value</li>
<li>scope? yep, probably functions</li>
<li>don't mutate (esp. not out of scope)</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgca6732a">
<h2 id="orgca6732a">What are we learning today?</h2>
</section>
</section>
<section>
<section id="slide-orgc6ca67f">
<h2 id="orgc6ca67f">Standard ML</h2>
<div class="outline-text-2" id="text-orgc6ca67f">
</div></section>
<section id="slide-org58536a7">
<h3 id="org58536a7">ML</h3>
<ul>
<li>Robin Milner, 1973 University of Edinburgh</li>
<li>Language spec, not implementation</li>
<li>"LISP with types"</li>

</ul>
</section>
<section id="slide-org7a3ee44">
<h3 id="org7a3ee44">Standard ML</h3>
<ul>
<li>Proposed 1983</li>
<li>Defined 1990</li>
<li>Revised 1997</li>
<li>Implemented by Princeton &amp; Bell Labs as SML/NJ</li>
<li>Grandparent of OCaml, Haskell, F#, Elm, Idris</li>

</ul>
</section>
<section id="slide-orgd51f2c5">
<h3 id="orgd51f2c5">Features of ML</h3>
<ul>
<li>Functional programming (but not pure)</li>
<li>call-by-value</li>
<li>eager evaluation</li>
<li>pattern matching</li>
<li>garbage collection</li>
<li>static typing</li>
<li>type inference</li>

</ul>
</section>
</section>
<section>
<section id="slide-org921462b">
<h2 id="org921462b">Racket</h2>
<div class="outline-text-2" id="text-org921462b">
</div></section>
<section id="slide-org0483129">
<h3 id="org0483129">LISP</h3>
<ul>
<li>John McCarthy, 1958 MIT</li>
<li>2nd oldest programming language</li>
<li>Started as a mathematical notation</li>
<li>LISt Processing</li>
<li>All program code comprised of lists (s-expressions)</li>

</ul>
</section>
<section id="slide-org1f063f4">
<h3 id="org1f063f4">Scheme</h3>
<ul>
<li>Guy Steele &amp; Gerald Sussman, 1975 MIT AI Lab</li>
<li>Small language (23 symbols, 11 are "convenience")</li>
<li>About 45 current implementations</li>
<li>Influenced Javascript, Ruby, Clojure</li>

</ul>
</section>
<section id="slide-orge557b7d">
<h3 id="orge557b7d">Features of Racket</h3>
<ul>
<li>tail-call optimization</li>
<li>green and OS threads</li>
<li>lexical closures</li>
<li>continuations</li>
<li>powerful macro system</li>
<li>pattern matching</li>
<li>contracts</li>

</ul>
</section>
</section>
<section>
<section id="slide-org22c0bf3">
<h2 id="org22c0bf3"><img src="http://i.imgur.com/mSIUhtX.jpg" alt="mSIUhtX.jpg" /></h2>
</section>
</section>
<section>
<section id="slide-org772bc0b">
<h2 id="org772bc0b">ML</h2>
<aside class="notes">
nil
</aside>
</section>
<section id="slide-org0d32743">
<h3 id="org0d32743">Values</h3>
<div class="org-src-container">

<pre><code class="sml" >(* exactly the same *)
val a = 5
val b: int = 5

a = b (* returns true - comparison, not assignment *)

val a = 6 (* completely redeclare a - don't do this *)
</code></pre>
</div>
</section>
<section id="slide-org3054b13">
<h3 id="org3054b13">Pairs</h3>
<aside class="notes">
<ul>
<li>Tuples are heterogeneous typed and fixed-length</li>
<li>Tuples and they can be nested</li>
<li>We use hash functions to access parts of tuples</li>
<li>Accessing values with hash functions is 1-based, not 0-based</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >val a: int * int = (5, 7)
val b: int * (bool * int) = (3, (true, 2))

(#1 a) = 5
(#2 a) = 7
(#1 (#2 b)) = true
</code></pre>
</div>
</section>
<section id="slide-org9634fe3">
<h3 id="org9634fe3">Records</h3>
<aside class="notes">
<ul>
<li>Records are another homogeneously typed structure</li>
<li>Again, we access values through hash functions on the keys</li>
<li>Tuples are in fact just records with numeric keys</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >val x: {a:int, b:string, c:bool} = {a=1, b="2", c=false}
val y = {foo=5}

#a x + #foo y = 6

val triple: string * bool * int = {2=false, 1="a", 3=5}
</code></pre>
</div>
</section>
<section id="slide-orgb04514f">
<h3 id="orgb04514f">Lists</h3>
<aside class="notes">
<ul>
<li>Lists are homogeneously typed and variable-length</li>
<li>The null function is our empty check for lists</li>
<li>hd and tl return the first and remaining elements of lists</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >val a: 'a list = []
val b: int list = [1, 2, 3]

val c = 0 :: b (* cons operator *)
c = [0, 1, 2, 3]

null [] = true
null b = false

hd b = 1
tl b = [2, 3]
tl (tl (tl b)) = []
</code></pre>
</div>
</section>
<section id="slide-orgde392ca">
<h3 id="orgde392ca">Functions</h3>
<aside class="notes">
<p>
Here we see a couple functions defined.
</p>
<ul>
<li>Parameter types occur after parameters, separated by colon</li>
<li>ML is expression-based</li>
<li>Expressions are type safe</li>
<li>∴ every if has a then and else, both returning same type</li>
<li>function return type follows parameters, separated by colon</li>
<li>function parameters are tuples</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >(* int -> int *)
fun add1 (x: int) = x + 1

(* int * int -> int *)
fun pow (x: int, y: int) =
    if   y = 0
    then 1
    else x * pow(x, y - 1)

fun cube (x: int): int = pow (x, 3)

val b = (2, 3)
pow b = 8
pow b = pow(2,3)
</code></pre>
</div>
</section>
<section id="slide-org0905592">
<h3 id="org0905592">Recursion</h3>
<aside class="notes">
<ul>
<li>No "for" loops in SML</li>
<li>Recursion is standard for iteration</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun sum (xs: int list) =
    if   null xs
    then 0
    else hd xs + sum (tl xs)

fun concat (xs: int list, ys: int list) =
    if   null xs
    then ys
    else hd xs :: concat (tl xs, ys)
</code></pre>
</div>
</section>
<section id="slide-orgeb70ccb">
<h3 id="orgeb70ccb">Local bindings</h3>
<aside class="notes">
<ul>
<li>Lexical scoping gives us local bindings</li>
<li>local bindings unavailable outside function</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun local_bindings (x: int) =
    let val a = if x > 0 then x else ~x (* same as: abs x *)
        val b = a + 100
    in
        if b > 200 then b div 2 else b * b
    end

fun range (x: int) =
    let
        fun range (y: int) =
            if y = x
            then x :: []
            else y :: range (y + 1)
    in
        range 0
    end
</code></pre>
</div>
</section>
<section id="slide-orgb17dfba">
<h3 id="orgb17dfba">Options</h3>
<aside class="notes">
<ul>
<li>Option is a container that holds a single value</li>
<li>We have isSome and valOf that work on options</li>
<li>isSome tells us if an Option is non-empty</li>
<li>valOf extracts values, or throws on NONE</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >val a: int option = SOME 5
val b: int option = NONE

isSome b = false
val c: int = if isSome a then valOf a else 0
</code></pre>
</div>
</section>
<section id="slide-org4aa40fe">
<h3 id="org4aa40fe">Options</h3>
<aside class="notes">
<ul>
<li>Options provide a safer mechanism than exception handling</li>
<li>Functions can expect to handle failure without exceptions or null</li>
<li>The first example here would throw an Empty exception if the
character can't be found</li>
<li>The second example won't throw, but uses a magic number as the
return value in its failure condition</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun strchr (s: char list, c: char, acc: int) =
    if   hd s = c
    then acc
    else strchr (tl s, c, acc + 1)

fun strchr' (s: char list, c: char, acc: int) =
    if   s = []
    then ~1
    else
        if   hd s = c
        then acc
        else strchr' (tl s, c, acc + 1)
</code></pre>
</div>
</section>
<section id="slide-orgc6c30c0">
<h3 id="orgc6c30c0">Options</h3>
<aside class="notes">
<ul>
<li>By using local bindings to create a private function, we get a
type-safe wrapper around an otherwise unsafe or inconsistent function</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun strchr (s: string, c: char) =
let
    fun strchr' (s: char list, acc: int) =
        if   s = []
        then ~1
        else
            if   hd s = c
            then acc
            else strchr' (tl s, acc + 1)

    val i = strchr' (explode s, 0)
in
    if i = ~1 then NONE else SOME i
end
</code></pre>
</div>
</section>
<section id="slide-orgd0d078c">
<h3 id="orgd0d078c">Data Types</h3>
<aside class="notes">
<ul>
<li>Not only is there the Option type, ML lets us define our own custom types</li>
<li>The type is defined on the left</li>
<li>Various constructors for the type go on the right</li>
<li>Constructor can be "of" an existing type, or a singleton</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >datatype Toppings = Mustard of string
                    | Pickles of int
                    | PepperAndOnion of int * int
                    | Relish
</code></pre>
</div>
</section>
<section id="slide-org90104c7">
<h3 id="org90104c7">Data Types</h3>
<aside class="notes">
<ul>
<li>These types can then be used much like any other type</li>
<li>This includes in conjunction with container types like list and option</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >datatype HotDogStyle = ToppedWith of Toppings list
                       | Plain

datatype HotDog = Link of HotDogStyle
                  | Brat of HotDogStyle;

val myToppings:HotDogStyle = [Mustard("dijon"), Relish, Pickles(2)]
val myDog = Brat (ToppedWith myToppings)
val yourDog = SOME(Link Plain)
</code></pre>
</div>
</section>
<section id="slide-org8dff770">
<h3 id="org8dff770">Type Bindings</h3>
<aside class="notes">
<ul>
<li>In addition to data types, we have type bindings</li>
<li>Type bindings work as synonyms for existing types</li>
<li>Type bindings do not create new constructors</li>
<li>This is especially useful for records: records as params are typing hell</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >type hotdogOrder = int * HotDog

val myOrder = 2 * myDog

type attendee = { name       : string,
                  company    : string option,
                  experience : int }

fun attendeeName (a: attendee):string = #name a

 attendeeName {name= "bob", company= NONE, experience= 2}
</code></pre>
</div>
</section>
<section id="slide-org173de11">
<h3 id="org173de11">Pattern Matching</h3>
<aside class="notes">
<ul>
<li>Case statements provide a way of "deconstructing" type constructors</li>
<li>Matches can be made on any type of constructor</li>
<li>this includes Option and list like we've seen already</li>
<li>Underscore is used as a wild card</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun likesBrats (d: HotDog) =
    case d of
        Brat _ => true
      | Link _ => false

likesBrats (Brat Plain)
</code></pre>
</div>
</section>
<section id="slide-orgdf66fec">
<h3 id="orgdf66fec">Pattern Matching</h3>
<aside class="notes">
<ul>
<li>using local bindings can clean up nested cases</li>
<li>here 'style' is used to "break off" the top constructor to get
the inner values</li>
<li>here's a sneak-peak at lambda syntax</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun likesRelish (d: HotDog) =
let
    val style = case d of
                    Brat s => s
                  | Link s => s
in
    case style of
        Plain => false
      | ToppedWith ts => List.exists (fn t => t = Relish) ts
end

likesRelish (Link Plain) = false
likesRelish (Brat (ToppedWith [Relish])) = true
</code></pre>
</div>
</section>
<section id="slide-orgb6ab7e1">
<h3 id="orgb6ab7e1">Pattern Matching</h3>
<aside class="notes">
<ul>
<li>Again, matches can be made on any type of constructor</li>
<li>Case statements can be used to destructure basically any type</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun addTuple t =
    case t of
        (a, b, c) => a + b + c

fun sum l =
    case l of
        []      => 0
      | h :: t  => h + (sum t)
</code></pre>
</div>
</section>
<section id="slide-orgdb1b0b3">
<h3 id="orgdb1b0b3">Pattern Matching Function Signatures</h3>
<aside class="notes">
<ul>
<li>Functions have a special form of case expression</li>
<li>They can be written as multiple definitions instead</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun likesBrats (Brat _) = true
  | likesBrats (Link _) = false

fun sum []       = 0
  | sum (h :: t) = h + (sum t)
</code></pre>
</div>
</section>
<section id="slide-orge2e6815">
<h3 id="orge2e6815">Recursive &amp; Polymorphic types</h3>
<aside class="notes">
<ul>
<li>Type variables are preceded with an apostrophe</li>
<li>They come before type name in data type definitions</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >datatype 'a Thing = Thing of 'a

(case Thing 1 of Thing n => n) = 1
(case Thing "Chimichanga" of Thing s => size s) = 11

datatype 'a lyzt = Emptee | Cawns of 'a * 'a lyzt

datatype ('a,'b) trie = Knowd of 'a * ('a,'b) trie * ('a,'b) trie
                      | Leef  of 'b
</code></pre>
</div>
</section>
<section id="slide-org8448ad4">
<h3 id="org8448ad4">Tail Recursion &amp; Accumulator Pattern</h3>
<aside class="notes">
<ul>
<li>Tail-call recursion optimization is of just called "tail recursion"</li>
<li>Return value of function is call to self</li>
<li>Can be optimized to not take up stack frames</li>
<li>No stack overflows ­ works like a loop</li>
<li>Accumulator pattern provides a private function which builds the result set</li>
<li>This leaves an optimized function without sullying the API</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun sum l =
    case l of
        []      => 0
      | h :: t  => h + (sum t)

fun sum l =
  let fun f(is, acc) =
    case is of
        []      => acc
      | h :: t  => f(t, h + acc)
    in
      f(l, 0)
    end
</code></pre>
</div>
</section>
<section id="slide-org5afd1bd">
<h3 id="org5afd1bd">Higher Order &amp; First Class Functions</h3>
<aside class="notes">
<ul>
<li>Higher order functions are functions that take other functions as
arguments</li>
<li>Functions in ML are first-class because they can be stored and
passed to functions as values, and returned from other functions</li>
<li>Functions can exist independently from definition as part of a
module as lambdas with the "fn" keyword.</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun repeat (f, n, x) =       (* ('a -> 'a) * int * 'a -> 'a *)
    if n = 0 then x else f (repeat(f, n - 1, x))

fun double x = x * 2         (* int -> int *)
repeat (double, 5, 2) = 64

repeat (fn x => x * x, 3, 2) = 256

val square = fn x => x * x   (* int -> int *)
repeat (square, 3, 2) = 256

fun add y = fn x => x + y    (* int -> int -> int *)
repeat (add 5, 10, 0) = 50
</code></pre>
</div>
</section>
<section id="slide-org8d8769f">
<h3 id="org8d8769f">Exercise time!</h3>
<aside class="notes">
<p>
fun map (f, xs) =
  case xs of
    [] =&gt; []
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">x :: xs' =&gt; (f x) :: map(f, xs'))</td>
</tr>
</tbody>
</table>

<p>
fun filter (f, xs) =
  case xs of
    [] =&gt; []
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">x :: xs =&gt; if f x then x :: filter(f, xs) else filter (f, xs)</td>
</tr>
</tbody>
</table>

</aside>
<ul>
<li>Define the function `map` to operate on list such that:</li>

</ul>
<div class="org-src-container">

<pre><code class="sml" >map (fn x => x + 1, [1,2,3,4,5]) = [2,3,4,5,6]
</code></pre>
</div>
<ul>
<li>Define the function `filter` to operate on lists such that:</li>

</ul>
<div class="org-src-container">

<pre><code class="sml" >filter (fn x => x mod 2 = 0, [1,2,3,4,5,6]) = [2,4,6]
</code></pre>
</div>
</section>
<section id="slide-org08a5393">
<h3 id="org08a5393">Folds</h3>
<aside class="notes">
<ul>
<li>Fold is a function that repeatedly applies a function to a
collection to accumulate a single result</li>
<li>folds are a common abstraction around the accumulator pattern we
just discussed</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun fold (f, acc, xs) =
  case xs of
    []      => acc
  | x :: xs => fold (f, f(acc, x), xs)

  fold(fn (x, y) => x + y, 0, [1,2,3,4,5]) = 15
  fold(fn (x, y) => x * y, 1, [1,2,3,4,5]) = 120
</code></pre>
</div>
</section>
<section id="slide-org3ea348b">
<h3 id="org3ea348b">Function composition</h3>
<aside class="notes">
<ul>
<li>Function composition is creating a new function which executes
two functions serially</li>
<li>The compose function is in the standard library as the function
lowercase "o"</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >fun compose (f, g) = fn x => f(g x)

fun add1 x = x + 1
fun times2 x = x * 2

(compose (times2, add1)) 2 = 6

(times2 o add1) 2 = 6
</code></pre>
</div>
</section>
<section id="slide-org640d7cb">
<h3 id="org640d7cb">The Pizza Operator</h3>
<aside class="notes">
<ul>
<li>Also known as the forward pipe</li>
<li>Is an easier way to think about composition</li>
<li>Is an idiom in other, newer languages like F#</li>
<li>Often an easier way to think about composition because of the
order of arguments</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >infix |>
fun x |> f = f x

2 |> add1 |> times2 = 6

fun add1ThenTimes2 x = x |> add1 |> times2

add1ThenTimes2 2 = 6
</code></pre>
</div>
</section>
<section id="slide-org24a8d07">
<h3 id="org24a8d07">Currying &amp; Partial Application</h3>
<aside class="notes">
<ul>
<li>Currying abstracts the idea of functions that take multiple arguments</li>
<li>Currying changes functions that take multiple arguments and
return a value into function that take 1 argument and return a
function which expects the next argument</li>
<li>Partial application applies a single argument to a curried
function and returns the next function</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="sml" >val add = fn x => fn y => x + y (* int -> int -> int *)
add (1)(2) = 3
add  1  2  = 3

val add1 = add 1                (* int -> int *)
add1 2 = 3
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-org6d8d1ff">
<h2 id="org6d8d1ff">BREAK</h2>
<aside class="notes">
nil
</aside>
<div class="org-src-container">

<pre><code class="sml" ></code></pre>
</div>
</section>
</section>
<section>
<section id="slide-org4cb5611">
<h2 id="org4cb5611">Racket</h2>
<aside class="notes">
<ul>
<li>Racket is a functional-focused language that has some additional
features allowing imperative operations</li>
<li>So racket supports many things we've already seen: lambdas,
closures, expression-based syntax and recursion instead of loops</li>
<li>Rather than a static type system, Racket is a dynamic language
where data can be treated as many different types, and everything
is data, even the code itself</li>
<li>As is famous of many LISPs, the syntax is very minimal, making use
of mostly parenthesis with the occasional square bracket thrown in
for good measure.</li>
<li>Because of its dynamic nature, Racket allows and additional family
of features we couldn't have in a statically typed language like
ML, such as macros, data-quoting and evaluation, and continuations</li>

</ul>

</aside>
<ul>
<li>Functional w/ imperative features</li>
<li>Dynamically typed</li>
<li>Minimalist syntax</li>
<li>Macros &amp; metaprogramming</li>

</ul>
</section>
<section id="slide-org6a33958">
<h3 id="org6a33958">Defining things</h3>
<aside class="notes">
<ul>
<li>In Racket, we use the define keyword similarly to how we would
use the `val` expression in ML</li>
<li>Notice that pairs of parenthesis (known as "forms" in LISP) are
evaluated with the first symbol for the operator or reference
name, followed by any arguments (such as with + or = below)</li>
<li>Speaking of + and =, these are not special syntax, they are
simply functions and can be treated exactly the same as any
function we write ourselves</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="racket" >#lang racket
(provide (all-defined-out))

(define hello "Hello, world!")

(define a 5)

(define b (+ a 7))

(= b 12) ; returns #t
</code></pre>
</div>
</section>
<section id="slide-org0371888">
<h3 id="org0371888">Functions</h3>
<aside class="notes">
<p>
Skipping straight to functions, since Racket's concepts of pairs and
records are fundamentally different from ML's and won't be nearly
as relevant in the coming exercises
</p>
<ul>
<li>Functions are defined using the same `define` keyword we use for
defining symbols, but functions are defined as forms</li>
<li>Racket's `lambda` keyword is used similarly to ML's `fn` keyworkd</li>
<li>Racket's conditionals are a little different, as there are no
`then` or `else` keywords. Rather, the `if` form simply takes
either 2 or 3 arguments</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="racket" >(define (add1 x) (+ x 1))
; is syntactic sugar for
(define add1 (lambda (x) (+ x 1)))

(define (pow x y)
  (if (= y 0)
      1
      (* x (pow x (- y 1)))))
</code></pre>
</div>
</section>
<section id="slide-org7cd0afb">
<h3 id="org7cd0afb">Lists</h3>
<aside class="notes">
<ul>
<li>Lists in Racket are at the same time both similar to and different
from ML's lists</li>
<li>Like ML, they are formed by "cons"ing values onto the front of
existing lists</li>
<li>In Racket, the empty list is represented by the `null` symbol, as
opposed to ML's empty list brackets</li>
<li>For convenience, there is a `list` form which accepts an variable
number of arguments to perform this successive "cons"ing for you</li>
<li>In Racket, the equivalent functions for head and tail are "car"
and "cdr", which while terrible, are historic names based on the
memory locations used in now-ancient LISP machines, so we're
stuck with them.</li>
<li>`null?` is the function which checks to see if a list is empty</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="racket" >(cons 1 (cons 2 (cons 3 (cons 4 null))))

(define first-four (list 1 2 3 4))

(= (car first-four) 1)          ; #t
(= 3 (length (cdr first-four))) ; #t

(define (sum xs)
  (if (null? xs)
      0
      (+ (car xs) (sum (cdr xs)))))

(define (concat xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (concat (cdr xs) ys))))
</code></pre>
</div>
</section>
<section id="slide-org3589df0">
<h3 id="org3589df0">Dynamic typing</h3>
<aside class="notes">
<p>
With ML, after talking about Lists, we jumped into talking about
defining our own special types. However in Racket, we're dealing
with dynamic typing, so we can create our own very flexible data
structures without the type checker getting in our way.
</p>
<ul>
<li>No compiler means we don't catch some small errors</li>
<li>Dynamic typing also means we can consume complex data structures
without trying to appease the type system.</li>
<li>We can define a function which recursively sums a list of numbers
or other lists without introducing any new concepts</li>
<li>Meanwhile the ML implementation requires defining a new datatype
to wrap the int and int list datatypes and subsequently
unwrapping those types with pattern matching to get at the
results we're interested in.</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="racket" >(a + b)            ; you probably meant (+ a b)
</code></pre>
</div>
<div class="org-src-container">

<pre><code class="racket" >(define (flat-sum xs)
  (if (null? xs)
      0
      (if (number? (car xs))
          (+ (car xs) (flat-sum (cdr xs)))
          (+ (flat-sum (car xs)) (flat-sum (cdr xs))))))
</code></pre>
</div>
<div class="org-src-container">

<pre><code class="sml" >datatype IntOrList = Intlist of IntOrList list | Num of int

fun flatSum []      = 0
  | flatSum (x::xs) =
      case x of
          Num n     => n + flatSum(xs)
        | Intlist n => flatSum(x) + flatSum(xs)

flatSum [Num 1, Num 2, Num 3, Intlist [Num 4, Num 5, Num 6]];
</code></pre>
</div>
</section>
<section id="slide-orga424f24">
<h3 id="orga424f24">Cond</h3>
<aside class="notes">
<ul>
<li>In ML, pattern matching was our Swiss army knife of conditional
branching and destructuring values based on their types</li>
<li>In Racket, the powerhouse for making these kinds of decisions is
cond, which provides pairs of tests along with what to do if that
test passes</li>
<li>In many ways, Racket's cond statement works much like switch
statements in other languages</li>
<li>Traditionally, #t is the last case in a cond, similar to the
"default" branch of switch statements</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="racket" >(define (flat-sum xs)
  (cond [(null? xs) 0]
        [(number? (car xs)) (+ (car xs) (flat-sum (cdr xs)))]
        [#t (+ (flat-sum (car xs)) (flat-sum (cdr xs)))]))
</code></pre>
</div>
</section>
<section id="slide-org2bd2caa">
<h3 id="org2bd2caa">Local bindings</h3>
<aside class="notes">
<ul>
<li>Like in ML, we can create local bindings that are only available
inside the current scope</li>
<li>Unlike ML's `let`, Racket's `let` statement evaluates all
statements in the environment in which the let is defined, so
they cannot reference one another</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="racket" >(define (flat-sum xs)
  (cond [(null? xs) 0]
        [(number? (car xs)) (+ (car xs) (flat-sum (cdr xs)))]
        [#t (let ([recur-sum (flat-sum (car xs))]
                  [tail-sum  (flat-sum (cdr xs))])
                  (+ recur-sum tail-sum))]))

(define (add-five-then-double x)
   (let* ([added (+ x 5)]
          [doubled (* added 2)]
     doubled)))
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-orgb72ae5b">
<h2 id="orgb72ae5b">BREAK</h2>
<aside class="notes">
nil
</aside>
<div class="org-src-container">

<pre><code class="sml" ></code></pre>
</div>
</section>
</section>
<section>
<section id="slide-org521c808">
<h2 id="org521c808">BREAK</h2>
<aside class="notes">
nil
</aside>
<div class="org-src-container">

<pre><code class="racket" ></code></pre>
</div>
</section>
</section>
</div>
</div>
<script src="reveal.js-3.3.0/lib/js/head.min.js"></script>
<script src="reveal.js-3.3.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'reveal.js-3.3.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }]
});
</script>
</body>
</html>
